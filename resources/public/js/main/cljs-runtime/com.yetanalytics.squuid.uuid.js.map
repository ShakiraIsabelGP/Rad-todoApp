{"version":3,"sources":["com/yetanalytics/squuid/uuid.cljc"],"mappings":";AAyBG,AAAeA,AAAY,AAAA,AAACC;AAG5B,AAAeC,AAAa,AAAA,AAACD;AAMhC;;;AAAA,AAAKE;AAIL;;;AAAA,AAAMC;AAAN,AAIW,AAACC;;AAEZ;;;;;;AAAA,AAAMC,AAKGC,AAASC;AALlB,AASK,AAAMD,AAAG,AAAWA;AACdC,AAAG,AAAWA;AADpB,AAEE,AACE,AAAGD,AAAGC;AADR;;AAAA,AAEE,AAACC,AAAEF,AAAGC;AAFR;;AAAA,AAGE,AAAGD,AAAGC;AAHR;;AAAA;;;;;AAKP;;;AAAA,AAAME,AAEGC;AAFT,AAOK,AAAMC,AAAE,AAAKD;AAAb,AACM,AAAK,AAAA,AAAA,AAACE,AAAKD,AAAO,AAAA,AAAA,AAACC,AAAKD,AACxB,AAAA,AAACE;;AAMZ,AAAA,AAAOC,AACJC;AADH,AAEE,AAAO,AAAA,AAAA,AAAA,AAAA,AAACC,AAAQ,AAAA,AAAA,AAA8BD,AAEvBA;;AAEzB,AAAA,AAAOE,AACJC;AADH,AAEE,AAAO,AAAA,AAAA,AAAA,AAAA,AAACF,AAAQ,AAAA,AAAA,AAAkBE,AAEXA;;AAEzB,AAAA,AAAOC,AACJD;AADH,AAEE,AAAME,AAAO,AAACC,AAAQH;AAAtB,AACE,AAAU,AAACI,AAASF;AAApB;AAAA,AAA4B,AAACH,AAAoBC;;;AACjDE;;AAMJ;;;;AAAA,AAAMG,AAGGR;AAHT,AAoBK,AAAMS,AAAW,AAACC,AAAc,AAAWV;AACrCW,AAAW,AAAKC;AAAL,AAAQ,AAAA,AAAW,AAAA,AAAK,AAAA,AAACd,AAAYc;;AAChDC,AAAW,AAAKC;AAAL,AAAe,AAAAC,AAAA,AAAO,AAACC,AAAKF;;AAF7C,AAGE,AAAA,AAAOG;;AAAP,AACE,AAEE,AAAI,AAAA,AAAMA,AACN,AAAA,AAAA,AAAA,AAAA,AAAMA,AAAAA,AACN,AAAA,AAAA,AAAA,AAAA,AAAMA,AAAAA;AACV,AAAML,AAAE,AAAMH,AAAWQ;AAAzB,AACE,AAAI,AAAI,AAAA,AAAgBL,AAAG,AAAA,AAAgBA;AACzC,AAAI,AAAA,AAAMH,AAAWQ;;AACjB,AAAO,AAAA,AAAKA;;;;AAChB,AAAI,AAAMR,AAAWQ,AAAE,AAACN,AAASC;;AAC7B,AAACC,AAASJ;;;AAVpB,AAaE,AAAA,AAAChB,AAAKwB;AACN,AAAML,AAAE,AAAMH,AAAWQ;AAAzB,AACE,AAAI,AAAI,AAAA,AAAgBL,AAAG,AAAA,AAAgBA;AACzC,AAAI,AAAA,AAAMH,AAAWQ;;AACjB,AAAO,AAAA,AAAKA;;;;AAChB,AAAI,AAAMR,AAAWQ,AAAE,AAACN,AAASC;;AAC7B,AAACC,AAASJ;;;AAnBpB,AAsBE,AAAAS,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAA,AAAAA,AAAAA,AAAUD,AAAAA;;AACV,AAAO,AAAA,AAAKA;;;;AAvBd,AA0BE,AAAClB,AAAqBC;;;;;;;;AAEjC,AAAA;;;;;AAAA,AAAAmB,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAIFlB;AAJJ,AAKG,AAACoB,AAAYpB,AAAG,AAACf;;;AALpB,AAAA,AAAA,AAAMiC,AAMFlB,AAASH;AANb,AAuBM,AAAMwB,AACA,AAAKC,AAAQ7B;AAAb,AAAgB,AAACoB,AAAK,AAAA,AAACU,AAAO,AAAGD,AAAQ,AAACE,AAAM/B;;AAEhDgC,AAAM,AAAC3C,AAAU,AAACmB,AAAQD;AAC1B0B,AAAM,AAAiBD,AAAI1C;AAC3B4C,AAAM,AAASF,AAAI5C;AACnB+C,AAAM,AAAA,AAAWF;AACjBG,AAAM,AAAA,AAAWF;AACjBG,AAAM,AAAA,AAACT,AAAeO;AACtBG,AAAM,AAAA,AAACV,AAAeQ;AAEtBG,AAAM,AAAA,AAACtC,AAAK,AAAWG;AAEvBoC,AAAc,AAAA,AAAA,AAAA,AAAKH,AAAMF,AAENG,AAAMF,AAEFG;AACvBE,AAAc,AAAAtB,AAAA,AAAOqB;AAlB3B,AAAA,AAAA,AAAA,AAmBcpC,AACAqC;;;AA3CpB,AAAA,AAAA,AAAMhB;;AAAN","names":["com.yetanalytics.squuid.uuid/bit-mask-16","js/BigInt","com.yetanalytics.squuid.uuid/bit-shift-16","com.yetanalytics.squuid.uuid/zero-uuid","com.yetanalytics.squuid.uuid/rand-uuid","cljs.core/random-uuid","com.yetanalytics.squuid.uuid/compare-uuid","u1","u2","cljs.core._EQ_","com.yetanalytics.squuid.uuid/extract-ts-bytes","uuid","s","cljs.core.subs","js/parseInt","com.yetanalytics.squuid.uuid/throw-inc-uuid-error","u","cljs.core.ex_info","com.yetanalytics.squuid.uuid/throw-neg-timestamp","ts","com.yetanalytics.squuid.uuid/ts->num","ts-num","cljs.core/inst-ms","cljs.core/nat-int?","com.yetanalytics.squuid.uuid/inc-uuid","u-char-arr","js/Array.from","inc-char","c","ret-uuid","char-arr","cljs.core/UUID","clojure.string.join","i","fexpr__69042","var_args","G__69044","com.yetanalytics.squuid.uuid/make-squuid","js/Error","com.yetanalytics.squuid.uuid.make_squuid","make-padding","max-len","cljs.core.repeat","cljs.core/count","ts'","ts-hi","ts-lo","ts-hs","ts-ls","ts-hp","ts-lp","u-str","raw-squuid","cooked-squuid"],"sourcesContent":["(ns com.yetanalytics.squuid.uuid\n  #?(:clj (:import [java.util UUID])\n     :cljs (:require [clojure.string :refer [join]])))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Private constants\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (def ^{:private true :const true} bit-mask-12\n     (unchecked-long 0x0000000000000FFF)))\n\n#?(:clj\n   (def ^{:private true :const true} bit-mask-16\n     (unchecked-long 0x000000000000FFFF)))\n\n#?(:clj\n   (def ^{:private true :const true} min-uuid-lsb\n     (unchecked-long 0x8000000000000000)))\n\n#?(:clj\n   (def ^{:private true :const true} max-uuid-lsb\n     (unchecked-long 0xBFFFFFFFFFFFFFFF)))\n\n#?(:cljs\n   (def ^:private bit-mask-16 (js/BigInt 0xFFFF)))\n\n#?(:cljs\n   (def ^:private bit-shift-16 (js/BigInt 16)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Helper vars and functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def zero-uuid\n  \"The v0 UUID of all zeroes.\"\n  #uuid \"00000000-0000-0000-0000-000000000000\")\n\n(defn rand-uuid\n  \"Generate a random v4 UUID.\"\n  []\n  #?(:clj (UUID/randomUUID)\n     :cljs (random-uuid)))\n\n(defn compare-uuid\n  \"Returns:\n   - (< uuid1 uuid2): -1\n   - (= uuid1 uuid2): 0\n   - (> uuid1 uuid2): 1\"\n  [^UUID u1 ^UUID u2]\n  #?(:clj\n     (.compareTo u1 u2)\n     :cljs\n     (let [u1 (.toString u1)\n           u2 (.toString u2)]\n       (cond\n         (< u1 u2) -1\n         (= u1 u2) 0\n         (> u1 u2) 1))))\n\n(defn extract-ts-bytes\n  \"Extracts the first 48 bits of a SQUUID corresponding to a timestamp.\"\n  [^UUID uuid]\n  #?(:clj\n     (-> (.getMostSignificantBits uuid)\n         (bit-shift-right 16))\n     :cljs\n     (let [s (str uuid)]\n       (-> (str (subs s 0 8) (subs s 9 13))\n           (js/parseInt 16)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Private helpers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- throw-inc-uuid-error\n  [u]\n  (throw (ex-info (str \"Cannot increment UUID \" u \" any further.\")\n                  {:type ::exceeded-max-uuid-node\n                   :uuid u})))\n\n(defn- throw-neg-timestamp\n  [ts]\n  (throw (ex-info (str \"Timestamp \" ts \" occurs before January 1, 1970\")\n                  {:type ::negative-timestamp\n                   :time ts})))\n\n(defn- ts->num\n  [ts]\n  (let [ts-num (inst-ms ts)]\n    (when-not (nat-int? ts-num) (throw-neg-timestamp ts))\n    ts-num))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Major functions\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn inc-uuid\n  \"Increment the UUID by one bit. Throws an exception if there are no available\n   bits left to increment.\"\n  [^UUID u]\n  #?(:clj ; Use bit operations\n     (let [uuid-msb (.getMostSignificantBits u)\n           uuid-lsb (.getLeastSignificantBits u)]\n       (cond\n         ;; least significant bits not maxed out\n         ;; (Note that `<` isn't used since Java doesn't have unsigned ints)\n         (not= uuid-lsb max-uuid-lsb)\n         (UUID. uuid-msb (inc uuid-lsb))\n         ;; most significant bits not maxed out\n         (not= (bit-and bit-mask-12 uuid-msb) bit-mask-12)\n         (UUID. (inc uuid-msb) min-uuid-lsb)\n         ;; oh no\n         :else\n         (throw-inc-uuid-error u)))\n\n     :cljs ; Use string operations\n     (let [u-char-arr (js/Array.from (.toString u))\n           inc-char   (fn [c] (.toString (inc (js/parseInt c 16)) 16))\n           ret-uuid   (fn [char-arr] (UUID. (join char-arr) nil))]\n       (loop [i 35] ; start from the back and inch forwards\n         (cond\n           ;; Regular hexes: 0x0 to 0xF\n           (or (< 23 i)\n               (< 19 i 23)\n               (< 14 i 18))\n           (let [c (aget u-char-arr i)]\n             (if (or (identical? \"F\" c) (identical? \"f\" c))\n               (do (aset u-char-arr i \"0\")\n                   (recur (dec i)))\n               (do (aset u-char-arr i (inc-char c))\n                   (ret-uuid u-char-arr))))\n\n           ;; Variant hexes: 0x0 to 0xB\n           (= 19 i)\n           (let [c (aget u-char-arr i)]\n             (if (or (identical? \"B\" c) (identical? \"b\" c))\n               (do (aset u-char-arr i \"8\")\n                   (recur (dec i)))\n               (do (aset u-char-arr i (inc-char c))\n                   (ret-uuid u-char-arr))))\n\n           ;; Dashes: ignore\n           (#{18 23} i)\n           (recur (dec i))\n\n           :else\n           (throw-inc-uuid-error u))))))\n\n(defn make-squuid\n  \"Make a new v8 sequential UUID. Uses `uuid` as the base UUID if provided;\n   otherwise uses a random v4 UUID as the base. Returns a map containing\n   `:base-uuid` and `:squuid`.\"\n  ([ts]\n   (make-squuid ts (rand-uuid)))\n  ([ts ^UUID u]\n   #?(:clj ; Use bit operations\n      (let [;; Timestamp\n            ts-long   (ts->num ts)\n            ;; Base UUID\n            uuid-msb  (.getMostSignificantBits u)\n            uuid-lsb  (.getLeastSignificantBits u)\n            ;; Putting it all together (and change version from v4 to v8)\n            uuid-msb' (-> (bit-or (bit-shift-left ts-long 16)\n                                  (bit-and bit-mask-16 uuid-msb))\n                          (bit-clear 14)\n                          (bit-set 15))\n            squuid    (UUID. uuid-msb' uuid-lsb)]\n        {:base-uuid u\n         :squuid    squuid})\n\n      :cljs ; Use string operations\n      (let [make-padding\n            (fn [max-len s] (join (repeat (- max-len (count s)) \"0\")))\n            ;; Timestamp manips\n            ts'   (js/BigInt (ts->num ts))\n            ts-hi (bit-shift-right ts' bit-shift-16)\n            ts-lo (bit-and ts' bit-mask-16)\n            ts-hs (.toString ts-hi 16)\n            ts-ls (.toString ts-lo 16)\n            ts-hp (make-padding 8 ts-hs)\n            ts-lp (make-padding 4 ts-ls)\n            ;; Base UUID manips\n            u-str (subs (.toString u) 15)\n            ;; Cook some SQUUID\n            raw-squuid    (str ts-hp ts-hs\n                               \"-\"\n                               ts-lp ts-ls\n                               \"-\"\n                               \"8\" u-str)\n            cooked-squuid (UUID. raw-squuid nil)]\n        {:base-uuid u\n         :squuid    cooked-squuid}))))\n"]}