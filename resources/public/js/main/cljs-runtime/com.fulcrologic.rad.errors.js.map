{"version":3,"sources":["com/fulcrologic/rad/errors.cljc"],"mappings":";AAuBA,AAAA,AAAAA,AAAAC,AAAAC,AAAAC,AAAAC;AAAA;AAAA,AAAA,AAASC,AAAe,AAAA,AAACC","names":["js/com","js/com.fulcrologic","js/com.fulcrologic.rad","js/com.fulcrologic.rad.errors","js/com.fulcrologic.rad.errors.prior-warnings","com.fulcrologic.rad.errors/prior-warnings","cljs.core/volatile!"],"sourcesContent":["(ns com.fulcrologic.rad.errors\n  \"Support for consistent error reporting across all RAD projects/plugins. These errors report during development, but\n  become no-ops in release builds that have zero overhead.\"\n  #?(:cljs (:require-macros [com.fulcrologic.rad.errors]))\n  (:require\n    [clojure.spec.alpha :as s]\n    [taoensso.encore :as enc]\n    [taoensso.timbre :as log]))\n\n#?(:clj\n   (defmacro required!\n     \"Log a readable error message and throw an exception if the given map `m` does not contain the key `k` whose\n     value passes `(pred (get m k))`.\"\n     ([context m k pred]\n      `(when-not (and\n                   (contains? ~m ~k)\n                   (~pred (get ~m ~k)))\n         (log/error ~context \"MUST include\" ~k \"that satisfies predicate\" ~(str pred))))\n     ([context m k]\n      `(when-not (contains? ~m ~k)\n         (log/error ~context \"MUST include\" ~k)))))\n\n;; TODO: Move into Fulcro proper as a macro that can be elided\n(defonce prior-warnings (volatile! #{}))\n\n(defmacro warn-once!\n  [& args] `(when (log/may-log? :info)\n              (when-not (contains? @prior-warnings [~@args])\n                (vswap! prior-warnings conj [~@args])\n                (log/warn ~@args))))\n"]}