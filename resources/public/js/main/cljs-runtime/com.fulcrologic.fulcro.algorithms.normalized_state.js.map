{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/normalized_state.cljc"],"mappings":"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","names":["com.fulcrologic.fulcro.algorithms.normalized-state/integrate-ident","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","com.fulcrologic.fulcro.algorithms.normalized-state/remove-ident","com.fulcrologic.fulcro.algorithms.merge/remove-ident*","cljs.spec.alpha/def-impl","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl","cljs.spec.alpha/or-spec-impl","cljs.spec.alpha/cat-impl","map__63999","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","argspec63995","cljs.core.get","retspec63996","com.fulcrologic.guardrails.core/run-check","f63998","G__64004","vec__64005","seq__64006","cljs.core/seq","first__64007","cljs.core/first","cljs.core/next","vec__64011","seq__64012","first__64013","ret63997","com.fulcrologic.fulcro.algorithms.normalized-state/tree-path->db-path","state","path","cljs.core/map?","cljs.core/vector?","h","t","new-path","np","cljs.core.conj","c","cljs.core.get_in","edn-query-language.core/ident?","cljs.core.not_EQ_","var_args","G__64024","com.fulcrologic.fulcro.algorithms.normalized-state/get-in-graph","js/Error","map__64025","argspec64015","retspec64016","f64018","ret64017","map__64027","cljs.core/ifn?","argspec64019","retspec64020","f64022","ret64021","state-map","cljs.core/any?","com.fulcrologic.fulcro.algorithms.normalized_state.get_in_graph","not-found","G__64030","com.fulcrologic.fulcro.algorithms.normalized-state/ui->props","this","com.fulcrologic.fulcro.algorithms.normalized_state.ui__GT_props","com.fulcrologic.fulcro.components/component->state-map","com.fulcrologic.fulcro.components/react-type","com.fulcrologic.fulcro.components/get-ident","component-class","ident","com.fulcrologic.fulcro.algorithms.denormalize/db->tree","com.fulcrologic.fulcro.components.get_query","p__64031","vec__64032","seq__64033","first__64034","com.fulcrologic.fulcro.algorithms.normalized-state/dissoc-in","m","k","ks","keys","temp__5733__auto__","nextmap","newmap","cljs.core.assoc","cljs.core.dissoc","cljs.spec.alpha.every_impl","G__64047","G__64049","com.fulcrologic.fulcro.algorithms.normalized-state/remove-entity","map__64050","retspec64040","argspec64039","f64042","ret64041","map__64052","G__64053","retspec64044","argspec64043","f64046","p1__64035#","or__4126__auto__","p1__64036#","p2__64037#","ret64045","com.fulcrologic.fulcro.algorithms.normalized_state.remove_entity","cascade","cljs.core/keyword?","cljs.core/set?","normalized-paths","ps","cljs.core/reduce-kv","v","paths*","cljs.core.filter","cljs.core/count","ident-specific-paths","a-path","vl","cljs.core/coll?","cljs.core/some","cljs.core._EQ_","remove-ident-at-path","a-normalized-path","cljs.core/every?","remove-ident-from-tables","cljs.core.reduce","state-without-entity","target-entity","cascaded-idents","table-key","cljs.core.map","entity-field","clojure.set.intersection","cljs.core/set","cljs.core/keys","final-state","edge","new-state","G__64067","G__64068","G__64070","com.fulcrologic.fulcro.algorithms.normalized-state/sort-idents-by","map__64071","G__64072","argspec64059","retspec64060","f64062","G__64074","ret64061","map__64075","G__64076","argspec64063","retspec64064","f64066","ret64065","vector-of-idents","sortkey-fn","comp-fn","kfn","cljs.core/vec","cljs.core.sort_by","com.fulcrologic.fulcro.algorithms.normalized_state.sort_idents_by","cljs.core/compare","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller!","p__64080","map__64081","seq64078","G__64079","self__4723__auto__","ref","args","cljs.core/swap!","cljs.core/update-in","com.fulcrologic.fulcro.algorithms.normalized-state/update-caller-in!","p__64086","map__64087","seq64083","G__64084","G__64085","mutation-env","cljs.core/deref","cljs.core.into","and__4115__auto__"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.normalized-state\n  \"Functions that can be used against a normalized Fulcro state database. This namespace also includes some handy aliases\n   to useful functions that work on normalized state from other namespaces.\"\n  #?(:cljs (:require-macros com.fulcrologic.fulcro.algorithms.normalized-state))\n  (:require\n    [clojure.set :as set]\n    [com.fulcrologic.fulcro.components :as comp]\n    [edn-query-language.core :as eql]\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [>defn =>]]\n    [com.fulcrologic.fulcro.algorithms.data-targeting :as targeting]\n    [com.fulcrologic.fulcro.algorithms.denormalize :as fdn]\n    [com.fulcrologic.fulcro.algorithms.merge :as merge]))\n\n(def integrate-ident\n  \"[state ident & named-parameters]\n\n  Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  targeting/integrate-ident*)\n\n(def remove-ident\n  \" [state-map ident path-to-idents]\n\n  Removes an ident, if it exists, from a list of idents in app state. This\n  function is safe to use within mutations.\"\n  merge/remove-ident*)\n\n\n(>defn tree-path->db-path\n  \"Convert a 'denormalized' path into a normalized one by walking the path in state treating ident-based edges\n  as jumps back to that location in state-map.\n\n  For example, one might find this to be true for a normalized db:\n\n  ```\n  state => {:person/id {1 {:person/id 1 :person/spouse [:person/id 3]}\n                        3 {:person/id 3 :person/first-name ...}}}\n\n  (tree-path->db-path state [:person/id 1 :person/spouse :person/first-name])\n  => [:person/id 3 :person/first-name]\n  ```\n  \"\n  ([state path]\n   [map? vector? => vector?]\n   (loop [[h & t] path\n          new-path []]\n     (if h\n       (let [np (conj new-path h)\n             c  (get-in state np)]\n         (if (eql/ident? c)\n           (recur t c)\n           (recur t (conj new-path h))))\n       (if (not= path new-path)\n         new-path\n         path)))))\n\n\n(>defn get-in-graph\n  \"Like clojure.core/get-in, but as it traverses the path it will follow idents in the state-map. This makes it similar\n   to a very targeted `db->tree`, but allows you to get something along a particular path without needing to parse a query.\n\n   Returns the data at the path, `not-found` (if specified) if nothing is found; otherwise nil.\n\n   See also `tree-path->db-path`.\"\n  ([state-map path]\n   [map? vector? => any?]\n   (get-in-graph state-map path nil))\n\n  ([state-map path not-found]\n   [map? vector? any? => any?]\n   (get-in state-map (tree-path->db-path state-map path) not-found)))\n\n\n(defn ui->props\n  \"Obtain a tree of props for a UI instance from the current application state. Useful in mutations where you want\n   to denormalize an entity from the state database. `this` can often be obtained from the mutation `env` at the\n  `:component` key.\"\n  ([this]\n   (ui->props (comp/component->state-map this) (comp/react-type this) (comp/get-ident this)))\n  ([state-map component-class ident]\n   (fdn/db->tree (comp/get-query component-class state-map) (get-in-graph state-map ident) state-map)))\n\n\n(defn dissoc-in\n  \"Dissociates an entry from a nested associative structure returning a new\n   nested structure. keys is a sequence of keys. Any empty maps that result\n   will not be present in the new structure.\n\n   The `ks` is *not* ident-aware. This function is here simply because it\n   is often needed, and clojure.core does not supply it.\n   \"\n  [m [k & ks :as keys]]\n  (if ks\n    (if-let [nextmap (get m k)]\n      (let [newmap (dissoc-in nextmap ks)]\n        (if (seq newmap)\n          (assoc m k newmap)\n          (dissoc m k)))\n      m)\n    (dissoc m k)))\n\n(>defn remove-entity\n  \"Remove the given entity at the given ident. Also scans all tables and removes any to-one or to-many idents that are\n  found that match `ident` (removes dangling pointers to the removed entity).\n\n  The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n  (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n  Returns the new state map with the entity(ies) removed.\"\n\n  ([state-map ident]\n   [map? eql/ident? => map?]\n   (remove-entity state-map ident #{}))\n\n  ([state-map ident cascade]\n   [map? eql/ident? (s/coll-of keyword? :kind set?) => map?]\n\n   (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n         normalized-paths         (letfn [(paths* [ps ks m]\n                                            (reduce-kv\n                                              (fn [ps k v]\n                                                (if (map? v)\n                                                  (paths* ps (conj ks k) v)\n                                                  (conj ps (conj ks k))))\n                                              ps\n                                              m))]\n                                    (filter #(< (count %) 4)\n                                      (paths* () [] state-map)))\n\n         ident-specific-paths     (fn [state ident]\n                                    (filter (fn [a-path]\n                                              (let [vl (get-in state a-path)]\n                                                (if (coll? vl)\n                                                  (or\n                                                    (some #{ident} vl)\n                                                    (= ident vl)))))\n                                      normalized-paths))\n\n         remove-ident-at-path     (fn [state a-normalized-path ident]\n                                    (let [v (get-in state a-normalized-path)]\n                                      (if (coll? v)\n                                        (cond\n                                          (= v ident) (dissoc-in state a-normalized-path)\n                                          (every? eql/ident? v) (merge/remove-ident* state ident a-normalized-path)\n                                          :else state)\n                                        state)))\n\n\n         remove-ident-from-tables (fn [state ident]\n                                    (reduce #(remove-ident-at-path %1 %2 ident)\n                                      state\n                                      (ident-specific-paths state ident)))\n\n         state-without-entity     (->\n                                    ;; remove pointers to the entity\n                                    (remove-ident-from-tables state-map ident)\n                                    ;; remove the top-level entity\n                                    (dissoc-in ident))\n\n         target-entity            (get-in-graph state-map ident)\n\n         ;; Computed set of all affected entities when cascade option is provided\n         cascaded-idents          (let [table-key (first ident)]\n                                    (map\n                                      (fn [entity-field]\n                                        (get-in state-map\n                                          (conj [table-key (table-key target-entity)] entity-field)))\n                                      (set/intersection\n                                        cascade\n                                        (set (keys target-entity)))))\n\n         final-state              (reduce\n                                    (fn [state edge]\n                                      (if (every? eql/ident? edge)\n                                        (reduce (fn [new-state ident] (remove-entity new-state ident cascade)) state edge)\n                                        (remove-entity state edge cascade)))\n                                    state-without-entity\n                                    cascaded-idents)]\n\n     final-state)))\n\n\n;; This one isn't quite right yet...hold off\n#_(>defn remove-edge\n    \"Remove the given edge at the given path. Also scans all tables and removes any to-one or to-many idents that are\n    found that match `edge` (removes dangling pointers to the removed entity(ies).\n\n    The optional `cascade` parameter is a set of keywords that represent edges that should cause recursive deletes\n    (i.e. it indicates edge names that *own* something, indicating it is safe to remove those entities as well).\n\n    Returns the new state map with the entity(ies) removed.\"\n\n    ([state-map path-to-edge]\n     [map? vector? => any?]\n     (remove-edge state-map path-to-edge #{}))\n\n\n    ([state-map path-to-edge cascade]\n     [map? vector? (s/coll-of keyword? :kind set?) => map?]\n     (let [;; \"Walks the tree in a depth first manner and returns the normalized possible paths\"\n           normalized-paths (letfn [(paths* [ps ks m]\n                                      (reduce-kv\n                                        (fn [ps k v]\n                                          (if (map? v)\n                                            (paths* ps (conj ks k) v)\n                                            (conj ps (conj ks k))))\n                                        ps\n                                        m))]\n                              (filter #(< (count %) 4)\n                                (paths* () [] state-map)))\n\n           candidate        (let [vl (get-in state-map path-to-edge)]\n                              (if-not (vector? vl)\n                                nil\n                                (cond\n                                  (eql/ident? vl) [vl]\n                                  (every? eql/ident? vl) vl)))\n\n           final-state      (if (some #{path-to-edge} normalized-paths)\n                              (reduce\n                                #(remove-entity %1 %2 cascade)\n                                state-map\n                                candidate)\n                              state-map)]\n       final-state)))\n\n\n(>defn sort-idents-by\n  \"Returns the sorted version of the provided vector of idents.\n\n  Intended to be used as\n  ```\n  (sort-idents-by people-idents :person/name)\n  ```\n\n  NOTE: The order of parameters is different from clojure.core/sort-by to facilitate:\n\n  ```\n  (swap! state update-in [:person/id 1 :person/children]\n    (partial sort-idents-by @state) :person/first-name)\n\n  ```\n\n  You can optionally pass a `comp-fn` which is as-described in `sort-by`.\n  \"\n  ([state-map vector-of-idents sortkey-fn comp-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? ifn? => any?]\n   (let [kfn (fn [ident] (sortkey-fn (get-in state-map ident)))]\n     (vec (sort-by kfn comp-fn vector-of-idents))))\n  ([state-map vector-of-idents sortkey-fn]\n   [map? (s/every eql/ident? :kind vector?) ifn? => any?]\n   (sort-idents-by state-map vector-of-idents sortkey-fn compare)))\n\n\n(defn update-caller!\n  \"Runs clojure.core/update on the table entry in the state database that corresponds\n   to the mutation caller (which can be explicitly set via `:ref` when calling `transact!`).\n\n   Equivalent to\n   ```\n   (apply swap! (:state env) update-in (:ref env) ...)\n   ```\n   \"\n\n  [{:keys [state ref]} & args]\n  (apply swap! state update-in ref args))\n\n\n(defn update-caller-in!\n  \"Like swap! but starts at the ref from `env`, adds in supplied `path` elements\n  (resolving across idents if necessary). Finally runs an update-in on that resultant\n  path with the given `args`.\n\n   Equivalent to:\n   ```\n   (swap! (:state env) update-in (tree-path->db-path @state (into (:ref env) path)) args)\n   ```\n   with a small bit of additional sanity checking.\"\n\n  [{:keys [state ref] :as mutation-env} path & args]\n  (let [path (tree-path->db-path @state (into ref path))]\n    (if (and path (get-in-graph @state path))\n      (apply swap! state update-in path args)\n      @state)))\n\n#?(:clj\n   (defmacro swap!->\n     \"A useful macro for threading multiple operations together on an atom (e.g. state atom in mutation)\n\n     Equivalent to:\n     ```\n     (swap! atom (fn [s] (-> s ...forms...)))\n     ```\n\n     For example\n\n     ```\n     (swap!-> (:state env)\n       (merge/merge-component ...)\n       (integrate-ident* ...))\n     ```\n     \"\n     [atom & forms]\n     `(swap! ~atom (fn [s#] (-> s# ~@forms)))))\n"]}