{
"version":3,
"file":"goog.crypt.hash.js",
"lineCount":8,
"mappings":"AAqBAA,IAAA,CAAKC,OAAL,CAAa,iBAAb,CAAA;AAUAD,IAAA,CAAKE,KAAL,CAAWC,IAAX,GAAkBC,QAAQ,EAAG;AAK3B,MAAA,CAAKC,SAAL,GAAiB,EAAjB;AAL2B,CAA7B;AAYAL,IAAA,CAAKE,KAAL,CAAWC,IAAX,CAAgBG,SAAhB,CAA0BC,KAA1B,GAAkCP,IAAlC,CAAuCQ,cAAvC;AAkBAR,IAAA,CAAKE,KAAL,CAAWC,IAAX,CAAgBG,SAAhB,CAA0BG,MAA1B,GAAmCT,IAAnC,CAAwCQ,cAAxC;AAOAR,IAAA,CAAKE,KAAL,CAAWC,IAAX,CAAgBG,SAAhB,CAA0BI,MAA1B,GAAmCV,IAAnC,CAAwCQ,cAAxC;;",
"sources":["goog/crypt/hash.js"],
"sourcesContent":["// Copyright 2011 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Abstract cryptographic hash interface.\n *\n * See goog.crypt.Sha1 and goog.crypt.Md5 for sample implementations.\n *\n */\n\ngoog.provide('goog.crypt.Hash');\n\n\n\n/**\n * Create a cryptographic hash instance.\n *\n * @constructor\n * @struct\n */\ngoog.crypt.Hash = function() {\n  /**\n   * The block size for the hasher.\n   * @type {number}\n   */\n  this.blockSize = -1;\n};\n\n\n/**\n * Resets the internal accumulator.\n */\ngoog.crypt.Hash.prototype.reset = goog.abstractMethod;\n\n\n/**\n * Adds a byte array (array with values in [0-255] range) or a string (must\n * only contain 8-bit, i.e., Latin1 characters) to the internal accumulator.\n *\n * Many hash functions operate on blocks of data and implement optimizations\n * when a full chunk of data is readily available. Hence it is often preferable\n * to provide large chunks of data (a kilobyte or more) than to repeatedly\n * call the update method with few tens of bytes. If this is not possible, or\n * not feasible, it might be good to provide data in multiplies of hash block\n * size (often 64 bytes). Please see the implementation and performance tests\n * of your favourite hash.\n *\n * @param {Array<number>|Uint8Array|string} bytes Data used for the update.\n * @param {number=} opt_length Number of bytes to use.\n */\ngoog.crypt.Hash.prototype.update = goog.abstractMethod;\n\n\n/**\n * @return {!Array<number>} The finalized hash computed\n *     from the internal accumulator.\n */\ngoog.crypt.Hash.prototype.digest = goog.abstractMethod;\n"],
"names":["goog","provide","crypt","Hash","goog.crypt.Hash","blockSize","prototype","reset","abstractMethod","update","digest"]
}
