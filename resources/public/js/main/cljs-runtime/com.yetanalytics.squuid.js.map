{"version":3,"sources":["com/yetanalytics/squuid.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.core/uuid?","cljs.spec.alpha/with-gen","cljs.core.partial","cljs.core/instance?","js/Date","cljs.spec.alpha.gen","cljs.core/inst?","com.yetanalytics.squuid/current-time-atom","cljs.core.atom","com.yetanalytics.squuid.time/zero-time","com.yetanalytics.squuid.uuid/zero-uuid","com.yetanalytics.squuid/reset-all!","cljs.core/reset!","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl","cljs.spec.alpha/cat-impl","cljs.spec.alpha/map-spec-impl","G__69049","cljs.core/map?","cljs.core/contains?","com.yetanalytics.squuid/generate-squuid*","ts","com.yetanalytics.squuid.time/current-time","cljs.core.swap_BANG_","m","com.yetanalytics.squuid.time/before?","cljs.core.assoc","cljs.core.merge","com.yetanalytics.squuid.uuid.make_squuid","cljs.core.update","com.yetanalytics.squuid.uuid/inc-uuid","com.yetanalytics.squuid/generate-squuid","cljs.spec.alpha/and-spec-impl","p1__69050#","cljs.core/inst-ms","com.yetanalytics.squuid.time/max-seconds","com.yetanalytics.squuid/time->uuid","js/Error","com.yetanalytics.squuid/uuid->time","uuid","com.yetanalytics.squuid.uuid/extract-ts-bytes"],"sourcesContent":["(ns com.yetanalytics.squuid\n  (:require [clojure.spec.alpha :as s]\n            [com.yetanalytics.squuid.uuid :as u]\n            [com.yetanalytics.squuid.time :as t]\n            #?(:clj [clojure.spec.gen.alpha :as sgen])))\n\n;; This library generates sequential UUIDs, or SQUUIDs, based on the draft RFC\n;; for v8 UUIDS:\n;; https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format\n\n;; The original approach of generating a 48-bit timestamp and merging it into\n;; a v4 UUID is taken from the Laravel PHP library's orderedUuid function:\n;; https://itnext.io/laravel-the-mysterious-ordered-uuid-29e7500b4f8\n\n;; The idea of incrementing the least significant bit on a timestamp collision\n;; is taken from the ULID specification:\n;; https://github.com/ulid/spec\n\n(s/def ::base-uuid uuid?)\n(s/def ::squuid uuid?)\n(s/def ::timestamp\n  #?(:clj (s/with-gen (partial instance? java.time.Instant)\n            #(sgen/fmap (fn [ts] (t/ms->Instant (inst-ms ts)))\n                        (s/gen inst?)))\n     :cljs (s/with-gen (partial instance? js/Date)\n             #(s/gen inst?))))\n\n;; The atom is private so that only generate-squuid(*) can mutate it.\n;; Note that merging Instant/EPOCH with v0 UUID returns the v0 UUID again.\n(def ^:private current-time-atom\n  (atom {:timestamp t/zero-time\n         :base-uuid u/zero-uuid\n         :squuid    u/zero-uuid}))\n\n(defn reset-all!\n  \"Reset such that the starting timestamp and UUIDs are zeroed out. This\n   function is intended for use in development/testing.\"\n  []\n  (reset! current-time-atom\n          {:timestamp t/zero-time\n           :base-uuid u/zero-uuid\n           :squuid    u/zero-uuid}))\n\n(s/fdef generate-squuid*\n  :args (s/cat)\n  :ret (s/keys :req-un [::base-uuid ::timestamp ::squuid]))\n\n(defn generate-squuid*\n  \"Return a map containing the following:\n   :squuid     The v8 sequential UUID made up of a base UUID and timestamp.\n   :base-uuid  The base v4 UUID that provides the lower 80 bits.\n   :timestamp  The timestamp that provides the higher 48 bits.\n   \n   See `generate-squuid` for more details.\"\n  []\n  (let [ts (t/current-time)]\n    (swap! current-time-atom\n           (fn [m]\n             (if (t/before? (:timestamp m) ts)\n               (-> m\n                   (assoc :timestamp ts)\n                   (merge (u/make-squuid ts)))\n               (-> m\n                   (update :base-uuid u/inc-uuid)\n                   (update :squuid u/inc-uuid)))))))\n\n(s/fdef generate-squuid\n  :args (s/cat)\n  :ret ::squuid)\n\n(defn generate-squuid\n  \"Return a new v8 sequential UUID, or SQUUID. The most significant 48 bits\n   are created from a timestamp representing the current time, which always\n   increments in value. The least significant 80 bits are derived from\n   a base v4 UUID; since 6 bits are reserved (4 for the version and 2 for the\n   variant), this leaves 74 random bits, allowing for about 18.9 sextillion\n   random segments.\n   \n   The timestamp is coerced to millisecond resolution. Due to the 48 bit\n   maximum on the timestamp, the latest time supported is August 2, 10889.\n   \n   In case that this function (or `generate-squuid*`) is called multiple times\n   in the same millisecond, subsequent SQUUIDs are created by incrementing the\n   base UUID and thus the random segment of the SQUUID. An exception is thrown\n   in the unlikely case where all 74 random bits are 1s and incrementing can no\n   longer occur.\"\n  []\n  (:squuid (generate-squuid*)))\n\n(s/fdef time->uuid\n  :args (s/cat :ts (s/and inst? #(<= 0 (inst-ms %) t/max-seconds)))\n  :ret ::squuid)\n\n(defn time->uuid\n  \"Convert a timestamp to a UUID. The upper 48 bits represent\n   the timestamp, while the lower 80 bits are fixed at\n   `8FFF-8FFF-FFFFFFFFFFFF`.\"\n  [ts]\n  (assert (inst? ts))\n  (:squuid\n   (u/make-squuid ts #uuid \"00000000-0000-4FFF-8FFF-FFFFFFFFFFFF\")))\n\n(s/fdef uuid->time\n  :args (s/cat :uuid ::squuid)\n  :ret ::timestamp)\n\n(defn uuid->time\n  \"Convert a previously generated `uuid` to its corresponding timestamp.\n   Returns a java.time.Instant object in Clojure, #inst in ClojureScript.\"\n  [uuid]\n  (assert (uuid? uuid))\n  #?(:clj\n     (-> uuid\n         (u/extract-ts-bytes)\n         (t/ms->Instant))\n     :cljs\n     (-> uuid\n         (u/extract-ts-bytes)\n         (js/Date.))))\n"]}