{"version":3,"sources":["com/fulcrologic/rad/type_support/js_date_formatter.cljs"],"mappings":"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","names":["com.fulcrologic.rad.type-support.js-date-formatter/tokenize","format-str","add-token","p__72241","map__72242","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","literal?","letters","acc","cljs.core/seq","cljs.core.update","cljs.core/conj","G__72244","clojure.string.join","cljs.core/PersistentArrayMap","cljs.core.reduce","p__72245","map__72246","prior-letter","letter","cljs.core._EQ_","cljs.core.assoc","and__4115__auto__","p__72248","map__72249","com.fulcrologic.rad.type-support.js-date-formatter/std-formatter","zero-pad?","options","zero-pad","s","cljs.core/count","locale-name","zone-name","formatter","js/Intl.DateTimeFormat","cljs.core/clj->js","cljs.core.merge","cljs.core.dissoc","inst","G__72251","com.fulcrologic.rad.type-support.js-date-formatter/zone-name-formatter","format","cljs.core/last","clojure.string.split","com.fulcrologic.rad.type-support.js-date-formatter/seconds->zone-offset","totalSeconds","size","absTotalSeconds","Math/abs","absSeconds","cljs.core/mod","absHours","absMinutes","sign","hours","mins","secs","G__72252","com.fulcrologic.rad.type-support.js-date-formatter/zone-offset-formatter","_","z","cljc.java_time.zone_id.of","i","cljc.java-time.instant/of-epoch-milli","cljs.core/inst-ms","or__4126__auto__","js/Date","offset","cljc.java-time.zoned-date-time/get-offset","cljc.java_time.zoned_date_time.of_instant","cljc.java-time.zone-offset/get-total-seconds","com.fulcrologic.rad.type-support.js-date-formatter/format-map","G__72254","cljs.core/re-matches","cljs.core/second","clojure.string/trim","com.fulcrologic.rad.type-support.js-date-formatter/new-formatter","tokens","generator","token","cljs.core/map?","cljs.core/constantly","f","generators","cljs.core.mapv","cljs.core.map","gen"],"sourcesContent":["(ns com.fulcrologic.rad.type-support.js-date-formatter\n  \"An implementation of date formatting that uses ISO format specifiers, but uses browser built-in Intl support\n   to get the locale-dependent values\"\n  (:require\n    [clojure.string :as str]\n    [cljc.java-time.zoned-date-time :as zdt]\n    [taoensso.timbre :as log]\n    [cljc.java-time.zone-id :as zone-id]\n    [cljc.java-time.zone-offset :as zo]\n    [cljc.java-time.instant :as instant]))\n\n(def tokenize\n  \"[format-str]\n\n   Turns a string that has repeating characters into groups of those repeating letters. This function is memoized, so\n   it is best to ONLY use it on date/time format patterns, of which there will likely be few.\"\n  (fn [format-str]\n    (let [add-token (fn [{:keys [literal? letters] :as acc}]\n                      (if (seq letters)\n                        (update acc :tokens conj (cond->> (str/join letters)\n                                                   literal? (array-map :literal)))\n                        acc))\n          acc       (let [letters (seq format-str)]\n                      (reduce\n                        (fn [{:keys [literal? prior-letter] :as acc} letter]\n                          (cond\n                            (and (= \\' letter) (= \\' prior-letter)) (-> acc\n                                                                      (assoc :literal? false\n                                                                             :letters []\n                                                                             :prior-letter \"\")\n                                                                      (update :tokens conj {:literal \\'}))\n                            (and literal? (= \\' letter)) (-> acc\n                                                           (add-token)\n                                                           (assoc :literal? false :letters [] :prior-letter \"\"))\n                            (= \\' letter) (-> acc\n                                            (add-token)\n                                            (assoc :literal? true :letters [] :prior-letter \\'))\n\n                            literal? (-> acc\n                                       (assoc :prior-letter letter)\n                                       (update :letters conj letter))\n\n                            (= prior-letter letter) (update acc :letters conj letter)\n                            :else (-> acc\n                                    (add-token)\n                                    (assoc :prior-letter letter)\n                                    (assoc :letters [letter]))))\n                        {:tokens       []\n                         :literal?     false\n                         :letters      []\n                         :prior-letter nil}\n                        letters))]\n      (-> acc\n        (add-token)\n        :tokens))))\n\n(defn- std-formatter [{:keys [zero-pad?] :as options}]\n  (let [zero-pad (fn [s] (if (= 1 (count s))\n                           (str \"0\" s)\n                           s))]\n    (fn [locale-name zone-name]\n      (let [formatter (js/Intl.DateTimeFormat. locale-name (clj->js (merge {:timeZone zone-name}\n                                                                      (dissoc options :zero-pad?))))]\n        (fn [inst]\n          (cond-> (.format formatter inst)\n            zero-pad? zero-pad))))))\n\n(defn- zone-name-formatter [format]\n  (fn [locale-name zone-name]\n    (let [formatter (js/Intl.DateTimeFormat. locale-name #js {:timeZone     zone-name\n                                                              :timeZoneName format\n                                                              :minute       \"numeric\"})]\n      (fn [inst]\n        (last (str/split (.format formatter inst) #\"\\s+\"))))))\n\n(defn- seconds->zone-offset [^long totalSeconds size]\n  (let [absTotalSeconds (int (Math/abs totalSeconds))\n        absSeconds      (int (mod absTotalSeconds 60))      ;\n        absHours        (int (/ absTotalSeconds 3600))\n        absMinutes      (int (mod (/ absTotalSeconds 60) 60))\n        sign            (if (neg? totalSeconds) \"-\" \"+\")\n        hours           (str (if (< absHours 10) \"0\" \"\") absHours)\n        mins            (str (if (< absMinutes 10) \"0\" \"\") absMinutes)\n        secs            (str (if (< absSeconds 10) \"0\" \"\") absSeconds)]\n    (if (zero? totalSeconds)\n      \"Z\"\n      (case size\n        1 (str sign hours (when (pos? absMinutes) mins))\n        2 (str sign hours mins)\n        3 (str sign hours \":\" mins)\n        4 (str sign hours mins (when (pos? absSeconds) secs))\n        5 (str sign hours \":\" mins (when (pos? absSeconds) (str \":\" secs)))\n        nil))))\n\n(defn- zone-offset-formatter [size]\n  (fn [_ zone-name]\n    (let []\n      (fn [inst]\n        (let [z      (zone-id/of zone-name)\n              i      (instant/of-epoch-milli (inst-ms (or inst (js/Date.))))\n              offset (zdt/get-offset (zdt/of-instant i z))]\n          (seconds->zone-offset (zo/get-total-seconds offset) size))))))\n\n(def format-map\n  {\"a\"     (fn [locale-name zone-name]\n             (let [formatter (js/Intl.DateTimeFormat.\n                               locale-name\n                               #js {:timeZone zone-name\n                                    :hour12   true\n                                    :hour     \"numeric\"})]\n               (fn [inst]\n                 (or\n                   (some-> (re-matches #\"^\\d+(.*)$\" (.format formatter inst)) (second) (str/trim))\n                   \"\"))))\n   ;; If you don't include some element of time, then zone name includes the whole darn date :(\n   \"Z\"     (zone-name-formatter \"short\")\n   \"ZZ\"    (zone-name-formatter \"short\")\n   \"ZZZ\"   (zone-name-formatter \"short\")\n   \"ZZZZ\"  (zone-name-formatter \"long\")\n   \"X\"     (zone-offset-formatter 1)\n   \"XX\"    (zone-offset-formatter 2)\n   \"XXX\"   (zone-offset-formatter 3)\n   \"XXXX\"  (zone-offset-formatter 4)\n   \"XXXXX\" (zone-offset-formatter 5)\n   \"M\"     (std-formatter {:month \"numeric\"})\n   \"MM\"    (std-formatter {:month \"2-digit\"})\n   \"MMM\"   (std-formatter {:month \"short\"})\n   \"MMMM\"  (std-formatter {:month \"long\"})\n   \"MMMMM\" (std-formatter {:month \"narrow\"})\n   \"m\"     (std-formatter {:minute \"numeric\"})\n   \"mm\"    (std-formatter {:minute \"numeric\" :zero-pad? true})\n   \"d\"     (std-formatter {:day \"numeric\"})\n   \"dd\"    (std-formatter {:day \"numeric\" :zero-pad? true})\n   \"h\"     (fn [locale-name zone-name]\n             (let [formatter (js/Intl.DateTimeFormat.\n                               locale-name\n                               #js {:timeZone zone-name\n                                    :hour12   true\n                                    :hour     \"numeric\"})]\n               (fn [inst]\n                 (second (re-matches #\"^(\\d+).*$\" (.format formatter inst))))))\n   \"hh\"    (fn [locale-name zone-name]\n             (let [formatter (js/Intl.DateTimeFormat.\n                               locale-name\n                               #js {:timeZone zone-name\n                                    :hour12   true\n                                    :hour     \"2-digit\"})]\n               (fn [inst]\n                 (second (re-matches #\"^(\\d+).*$\" (.format formatter inst))))))\n   \"H\"     (std-formatter {:hour12 false :hour \"numeric\"})\n   \"HH\"    (std-formatter {:hour12 false :hour \"2-digit\"})\n   \"y\"     (std-formatter {:year \"numeric\"})\n   \"yy\"    (std-formatter {:year \"2-digit\"})\n   \"yyy\"   (std-formatter {:year \"numeric\"})\n   \"yyyy\"  (std-formatter {:year \"numeric\"})\n   \"E\"     (std-formatter {:weekday \"short\"})\n   \"EE\"    (std-formatter {:weekday \"long\"})\n   \"EEE\"   (std-formatter {:weekday \"narrow\"})\n   \"s\"     (std-formatter {:second \"numeric\"})\n   \"ss\"    (std-formatter {:second \"numeric\" :zero-pad? true})})\n\n(defn new-formatter\n  \"Build a formatter. Returns a `(fn [inst] string?)`.\"\n  [format-str locale-name zone-name]\n  (let [tokens     (tokenize format-str)\n        generator  (fn [token]\n                     (if (map? token)\n                       (constantly (:literal token))\n                       (let [f (get format-map token)]\n                         (if f\n                           (f locale-name zone-name)\n                           (constantly token)))))\n        generators (mapv generator tokens)]\n    (fn [inst] (str/join (map (fn [gen] (gen inst)) generators)))))\n"]}