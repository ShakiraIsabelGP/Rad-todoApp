{"version":3,"sources":["com/wsscode/common/combinatorics.cljc"],"mappings":";AAEA,AAAA;;;AAAA,AAAAA,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAEDI;AAFL,AAGE,AAAMC,AAAgB,AAACC,AAAIF;AACrBG,AACA,AAAUC;AAAV,AACE,AAAMC,AACA,AAAKD;AAAL,AACE,AAAOE,AAAE,AAAA,AAAK,AAACC,AAAMH;AAAUA,AAAOA;;AAAtC,AACE,AAAI,AAAA,AAACI,AAAEF;AAAP;;AACI,AAAAG,AAAa,AAACE,AAAK,AAACP,AAAAA,AAAAA,AAAOE,AAAAA;AAA3B,AAAA,AAAAG;AAAA,AAAAA,AAASC;AAAT,AACE,AAACE,AAAMR,AAAOE,AAAEI;;AAChB,AAAO,AAAA,AAAKJ;AAAG,AAACM,AAAMR,AAAOE,AAAE,AAACL,AAAAA,AAAAA,AAAgBK,AAAAA;;;;;;;;;AANhE,AAOE,AAAMF;AAAN,AACE,AAACS,AAAK,AAACC,AAAIC,AAAMX,AACX,AAAAY,AAAA,AAAA;AAAA,AAAU,AAACb,AAAK,AAACE,AAAUD;AAA3B,AAAA;;AAFR;;;AAVV,AAaE,AAAM,AAACa,AAAOlB,AAAIC;AAAlB,AACE,AAAAgB,AAAA,AAAA;AAAA,AAAU,AAACb,AAAKF;AAAhB,AAAA;;AADF;;;;AAhBJ,AAAA,AAAA,AAAML;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAA,AAAAC,AAAAF;;;AAAA","names":["var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","com.wsscode.common.combinatorics/cartesian-product","seq80954","self__4724__auto__","cljs.core/seq","seqs","v-original-seqs","cljs.core/vec","step","v-seqs","increment","i","cljs.core/count","cljs.core._EQ_","temp__5733__auto__","rst","cljs.core/next","cljs.core.assoc","cljs.core/cons","cljs.core.map","cljs.core/first","cljs.core/LazySeq","cljs.core/every?"],"sourcesContent":["(ns com.wsscode.common.combinatorics)\n\n(defn cartesian-product\n  \"All the ways to take one item from each sequence\"\n  [& seqs]\n  (let [v-original-seqs (vec seqs)\n        step\n        (fn step [v-seqs]\n          (let [increment\n                (fn [v-seqs]\n                  (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                    (if (= i -1) nil\n                        (if-let [rst (next (v-seqs i))]\n                          (assoc v-seqs i rst)\n                          (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n            (when v-seqs\n              (cons (map first v-seqs)\n                    (lazy-seq (step (increment v-seqs)))))))]\n    (when (every? seq seqs)\n      (lazy-seq (step v-original-seqs)))))\n"]}