{"version":3,"sources":["com/yetanalytics/squuid/time.cljc"],"mappings":";AAGA,AAAeA,AACb,AAAA,AAAA;AAGF;;;AAAA,AAAKC;AAIL;;;;AAAKC,AAIM,AAAAC,AAAA;AAEX;;;AAAA,AAAMC;AAAN,AAGE,AAAMC,AACsB,AAAMF;AADlC,AAEE,AAAQ,AAAIE,AAAaJ;AAAzB;AAAA,AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAA,AACQN;;;AAEC,AAAAG,AAAUE;;AAEvB;;;AAAA,AAAME,AAGOC,AAAMC;AAHnB,AAG0B,AAAGD,AAAMC","names":["com.yetanalytics.squuid.time/max-time-emsg","com.yetanalytics.squuid.time/max-seconds","com.yetanalytics.squuid.time/zero-time","js/Date","com.yetanalytics.squuid.time/current-time","curr-seconds","js/Error","com.yetanalytics.squuid.time/before?","time1","time2"],"sourcesContent":["(ns com.yetanalytics.squuid.time\n  #?(:clj (:import [java.time Instant])))\n\n(def ^:private max-time-emsg\n  (str \"Cannot generate SQUUID past August 2, 10889.\"\n       \" The timestamp would have exceeded 48 bits.\"))\n\n(def max-seconds\n  \"The maximum underlying value of a 48-bit timestamp.\"\n  0x0000FFFFFFFFFFFF)\n\n(def zero-time\n  \"Return the timestamp corresponding to the beginning of the UNIX epoch,\n   on Jan 1, 1970.\"\n  #?(:clj Instant/EPOCH\n     :cljs (js/Date. 0)))\n\n(defn current-time\n  \"Return the timestamp corresponding to the current system time.\"\n  []\n  (let [curr-seconds #?(:clj (System/currentTimeMillis)\n                        :cljs (.now js/Date))]\n    (assert (<= curr-seconds max-seconds)\n            max-time-emsg)\n    #?(:clj (Instant/ofEpochMilli curr-seconds)\n       :cljs (js/Date. curr-seconds))))\n\n(defn before?\n  \"Does `time1` occur strictly before `time2`?\"\n  #?(:clj ([^Instant time1 ^Instant time2] (.isBefore time1 time2))\n     :cljs ([time1 time2] (< time1 time2))))\n\n#?(:clj\n   (defn ms->Instant\n     \"Convenience function returning a java.time.Instant object \n      given `ms` from the beginning of the UNIX epoch.\"\n     [ms]\n     (Instant/ofEpochMilli ms)))\n"]}