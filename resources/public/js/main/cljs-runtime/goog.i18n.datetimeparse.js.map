{
"version":3,
"file":"goog.i18n.datetimeparse.js",
"lineCount":499,
"mappings":"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",
"sources":["goog/i18n/datetimeparse.js"],
"sourcesContent":["// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Date/Time parsing library with locale support.\n */\n\n\n/**\n * Namespace for locale date/time parsing functions\n */\ngoog.provide('goog.i18n.DateTimeParse');\n\ngoog.require('goog.asserts');\ngoog.require('goog.date');\ngoog.require('goog.i18n.DateTimeFormat');\ngoog.require('goog.i18n.DateTimeSymbols');\n\n\n/**\n * DateTimeParse is for parsing date in a locale-sensitive manner. It allows\n * user to use any customized patterns to parse date-time string under certain\n * locale. Things varies across locales like month name, weekname, field\n * order, etc.\n *\n * This module is the counter-part of DateTimeFormat. They use the same\n * date/time pattern specification, which is borrowed from ICU/JDK.\n *\n * This implementation could parse partial date/time.\n *\n * Time Format Syntax: To specify the time format use a time pattern string.\n * In this pattern, following letters are reserved as pattern letters, which\n * are defined as the following:\n *\n * <pre>\n * Symbol   Meaning                 Presentation        Example\n * ------   -------                 ------------        -------\n * G        era designator          (Text)              AD\n * y#       year                    (Number)            1996\n * M        month in year           (Text & Number)     July & 07\n * d        day in month            (Number)            10\n * h        hour in am/pm (1~12)    (Number)            12\n * H        hour in day (0~23)      (Number)            0\n * m        minute in hour          (Number)            30\n * s        second in minute        (Number)            55\n * S        fractional second       (Number)            978\n * E        day of week             (Text)              Tuesday\n * D        day in year             (Number)            189\n * a        am/pm marker            (Text)              PM\n * k        hour in day (1~24)      (Number)            24\n * K        hour in am/pm (0~11)    (Number)            0\n * z        time zone               (Text)              Pacific Standard Time\n * Z        time zone (RFC 822)     (Number)            -0800\n * v        time zone (generic)     (Text)              Pacific Time\n * '        escape for text         (Delimiter)         'Date='\n * ''       single quote            (Literal)           'o''clock'\n * </pre>\n *\n * The count of pattern letters determine the format. <p>\n * (Text): 4 or more pattern letters--use full form,\n *         less than 4--use short or abbreviated form if one exists.\n *         In parsing, we will always try long format, then short. <p>\n * (Number): the minimum number of digits. <p>\n * (Text & Number): 3 or over, use text, otherwise use number. <p>\n * Any characters that not in the pattern will be treated as quoted text. For\n * instance, characters like ':', '.', ' ', '#' and '@' will appear in the\n * resulting time text even they are not embraced within single quotes. In our\n * current pattern usage, we didn't use up all letters. But those unused\n * letters are strongly discouraged to be used as quoted text without quote.\n * That's because we may use other letter for pattern in future. <p>\n *\n * Examples Using the US Locale:\n *\n * Format Pattern                         Result\n * --------------                         -------\n * \"yyyy.MM.dd G 'at' HH:mm:ss vvvv\" ->>  1996.07.10 AD at 15:08:56 Pacific Time\n * \"EEE, MMM d, ''yy\"                ->>  Wed, July 10, '96\n * \"h:mm a\"                          ->>  12:08 PM\n * \"hh 'o''clock' a, zzzz\"           ->>  12 o'clock PM, Pacific Daylight Time\n * \"K:mm a, vvv\"                     ->>  0:00 PM, PT\n * \"yyyyy.MMMMM.dd GGG hh:mm aaa\"    ->>  01996.July.10 AD 12:08 PM\n *\n * <p> When parsing a date string using the abbreviated year pattern (\"yy\"),\n * DateTimeParse must interpret the abbreviated year relative to some\n * century. It does this by adjusting dates to be within 80 years before and 20\n * years after the time the parse function is called. For example, using a\n * pattern of \"MM/dd/yy\" and a DateTimeParse instance created on Jan 1, 1997,\n * the string \"01/11/12\" would be interpreted as Jan 11, 2012 while the string\n * \"05/04/64\" would be interpreted as May 4, 1964. During parsing, only\n * strings consisting of exactly two digits, as defined by {@link\n * java.lang.Character#isDigit(char)}, will be parsed into the default\n * century. Any other numeric string, such as a one digit string, a three or\n * more digit string will be interpreted as its face value.\n *\n * <p> If the year pattern does not have exactly two 'y' characters, the year is\n * interpreted literally, regardless of the number of digits. So using the\n * pattern \"MM/dd/yyyy\", \"01/11/12\" parses to Jan 11, 12 A.D.\n *\n * <p> When numeric fields abut one another directly, with no intervening\n * delimiter characters, they constitute a run of abutting numeric fields. Such\n * runs are parsed specially. For example, the format \"HHmmss\" parses the input\n * text \"123456\" to 12:34:56, parses the input text \"12345\" to 1:23:45, and\n * fails to parse \"1234\". In other words, the leftmost field of the run is\n * flexible, while the others keep a fixed width. If the parse fails anywhere in\n * the run, then the leftmost field is shortened by one character, and the\n * entire run is parsed again. This is repeated until either the parse succeeds\n * or the leftmost field is one character in length. If the parse still fails at\n * that point, the parse of the run fails.\n *\n * <p> Now timezone parsing only support GMT:hhmm, GMT:+hhmm, GMT:-hhmm\n */\n\n\n\n/**\n * Construct a DateTimeParse based on current locale.\n * @param {string|number} pattern pattern specification or pattern type.\n * @param {!Object=} opt_dateTimeSymbols Optional symbols to use for this\n *     instance rather than the global symbols.\n * @constructor\n * @final\n */\ngoog.i18n.DateTimeParse = function(pattern, opt_dateTimeSymbols) {\n  goog.asserts.assert(\n      opt_dateTimeSymbols !== undefined ||\n          goog.i18n.DateTimeSymbols !== undefined,\n      'goog.i18n.DateTimeSymbols or explicit symbols must be defined');\n\n  this.patternParts_ = [];\n\n  /**\n   * Data structure with all the locale info needed for date formatting.\n   * (day/month names, most common patterns, rules for week-end, etc.)\n   * @const @private {!goog.i18n.DateTimeSymbolsType}\n   */\n  this.dateTimeSymbols_ = /** @type {!goog.i18n.DateTimeSymbolsType} */ (\n      opt_dateTimeSymbols || goog.i18n.DateTimeSymbols);\n  if (typeof pattern == 'number') {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n\n\n/**\n * Number of years prior to now that the century used to\n * disambiguate two digit years will begin\n *\n * @type {number}\n */\ngoog.i18n.DateTimeParse.ambiguousYearCenturyStart = 80;\n\n\n/**\n * Apply a pattern to this Parser. The pattern string will be parsed and saved\n * in \"compiled\" form.\n * Note: this method is somewhat similar to the pattern parsing method in\n *       datetimeformat. If you see something wrong here, you might want\n *       to check the other.\n * @param {string} pattern It describes the format of date string that need to\n *     be parsed.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.applyPattern_ = function(pattern) {\n  var inQuote = false;\n  var buf = '';\n\n  for (var i = 0; i < pattern.length; i++) {\n    var ch = pattern.charAt(i);\n\n    // handle space, add literal part (if exist), and add space part\n    if (ch == ' ') {\n      if (buf.length > 0) {\n        this.patternParts_.push({text: buf, count: 0, abutStart: false});\n        buf = '';\n      }\n      this.patternParts_.push({text: ' ', count: 0, abutStart: false});\n      while (i < pattern.length - 1 && pattern.charAt(i + 1) == ' ') {\n        i++;\n      }\n    } else if (inQuote) {\n      // inside quote, except '', just copy or exit\n      if (ch == '\\'') {\n        if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\\'') {\n          // quote appeared twice continuously, interpret as one quote.\n          buf += '\\'';\n          i++;\n        } else {\n          // exit quote\n          inQuote = false;\n        }\n      } else {\n        // literal\n        buf += ch;\n      }\n    } else if (goog.i18n.DateTimeParse.PATTERN_CHARS_.indexOf(ch) >= 0) {\n      // outside quote, it is a pattern char\n      if (buf.length > 0) {\n        this.patternParts_.push({text: buf, count: 0, abutStart: false});\n        buf = '';\n      }\n      var count = this.getNextCharCount_(pattern, i);\n      this.patternParts_.push({text: ch, count: count, abutStart: false});\n      i += count - 1;\n    } else if (ch == '\\'') {\n      // Two consecutive quotes is a quote literal, inside or outside of quotes.\n      if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\\'') {\n        buf += '\\'';\n        i++;\n      } else {\n        inQuote = true;\n      }\n    } else {\n      buf += ch;\n    }\n  }\n\n  if (buf.length > 0) {\n    this.patternParts_.push({text: buf, count: 0, abutStart: false});\n  }\n\n  this.markAbutStart_();\n};\n\n\n/**\n * Apply a predefined pattern to this Parser.\n * @param {number} formatType A constant used to identified the predefined\n *     pattern string stored in locale repository.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.applyStandardPattern_ = function(formatType) {\n  var pattern;\n  // formatType constants are in consecutive numbers. So it can be used to\n  // index array in following way.\n\n  // if type is out of range, default to medium date/time format.\n  if (formatType > goog.i18n.DateTimeFormat.Format.SHORT_DATETIME) {\n    formatType = goog.i18n.DateTimeFormat.Format.MEDIUM_DATETIME;\n  }\n\n  if (formatType < 4) {\n    pattern = this.dateTimeSymbols_.DATEFORMATS[formatType];\n  } else if (formatType < 8) {\n    pattern = this.dateTimeSymbols_.TIMEFORMATS[formatType - 4];\n  } else {\n    pattern = this.dateTimeSymbols_.DATETIMEFORMATS[formatType - 8];\n    pattern = pattern.replace(\n        '{1}', this.dateTimeSymbols_.DATEFORMATS[formatType - 8]);\n    pattern = pattern.replace(\n        '{0}', this.dateTimeSymbols_.TIMEFORMATS[formatType - 8]);\n  }\n  this.applyPattern_(pattern);\n};\n\n\n/**\n * Parse the given string and fill info into date object. This version does\n * not validate the input.\n * @param {string} text The string being parsed.\n * @param {goog.date.DateLike} date The Date object to hold the parsed date.\n * @param {number=} opt_start The position from where parse should begin.\n * @return {number} How many characters parser advanced.\n */\ngoog.i18n.DateTimeParse.prototype.parse = function(text, date, opt_start) {\n  var start = opt_start || 0;\n  return this.internalParse_(text, date, start, false /*validation*/);\n};\n\n\n/**\n * Parse the given string and fill info into date object. This version will\n * validate the input and make sure it is a valid date/time.\n * @param {string} text The string being parsed.\n * @param {goog.date.DateLike} date The Date object to hold the parsed date.\n * @param {number=} opt_start The position from where parse should begin.\n * @return {number} How many characters parser advanced.\n */\ngoog.i18n.DateTimeParse.prototype.strictParse = function(\n    text, date, opt_start) {\n  var start = opt_start || 0;\n  return this.internalParse_(text, date, start, true /*validation*/);\n};\n\n\n/**\n * Parse the given string and fill info into date object.\n * @param {string} text The string being parsed.\n * @param {goog.date.DateLike} date The Date object to hold the parsed date.\n * @param {number} start The position from where parse should begin.\n * @param {boolean} validation If true, input string need to be a valid\n *     date/time string.\n * @return {number} How many characters parser advanced.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.internalParse_ = function(\n    text, date, start, validation) {\n  var cal = new goog.i18n.DateTimeParse.MyDate_();\n  var parsePos = [start];\n\n  // For parsing abutting numeric fields. 'abutPat' is the\n  // offset into 'pattern' of the first of 2 or more abutting\n  // numeric fields. 'abutStart' is the offset into 'text'\n  // where parsing the fields begins. 'abutPass' starts off as 0\n  // and increments each time we try to parse the fields.\n  var abutPat = -1;  // If >=0, we are in a run of abutting numeric fields\n  var abutStart = 0;\n  var abutPass = 0;\n\n  for (var i = 0; i < this.patternParts_.length; i++) {\n    if (this.patternParts_[i].count > 0) {\n      if (abutPat < 0 && this.patternParts_[i].abutStart) {\n        abutPat = i;\n        abutStart = start;\n        abutPass = 0;\n      }\n\n      // Handle fields within a run of abutting numeric fields. Take\n      // the pattern \"HHmmss\" as an example. We will try to parse\n      // 2/2/2 characters of the input text, then if that fails,\n      // 1/2/2. We only adjust the width of the leftmost field; the\n      // others remain fixed. This allows \"123456\" => 12:34:56, but\n      // \"12345\" => 1:23:45. Likewise, for the pattern \"yyyyMMdd\" we\n      // try 4/2/2, 3/2/2, 2/2/2, and finally 1/2/2.\n      if (abutPat >= 0) {\n        // If we are at the start of a run of abutting fields, then\n        // shorten this field in each pass. If we can't shorten\n        // this field any more, then the parse of this set of\n        // abutting numeric fields has failed.\n        var count = this.patternParts_[i].count;\n        if (i == abutPat) {\n          count -= abutPass;\n          abutPass++;\n          if (count == 0) {\n            // tried all possible width, fail now\n            return 0;\n          }\n        }\n\n        if (!this.subParse_(\n                text, parsePos, this.patternParts_[i], count, cal)) {\n          // If the parse fails anywhere in the run, back up to the\n          // start of the run and retry.\n          i = abutPat - 1;\n          parsePos[0] = abutStart;\n          continue;\n        }\n      }\n\n      // Handle non-numeric fields and non-abutting numeric fields.\n      else {\n        abutPat = -1;\n        if (!this.subParse_(text, parsePos, this.patternParts_[i], 0, cal)) {\n          return 0;\n        }\n      }\n    } else {\n      // Handle literal pattern characters. These are any\n      // quoted characters and non-alphabetic unquoted\n      // characters.\n      abutPat = -1;\n      // A run of white space in the pattern matches a run\n      // of white space in the input text.\n      if (this.patternParts_[i].text.charAt(0) == ' ') {\n        // Advance over run in input text\n        var s = parsePos[0];\n        this.skipSpace_(text, parsePos);\n\n        // Must see at least one white space char in input\n        if (parsePos[0] > s) {\n          continue;\n        }\n      } else if (\n          text.indexOf(this.patternParts_[i].text, parsePos[0]) ==\n          parsePos[0]) {\n        parsePos[0] += this.patternParts_[i].text.length;\n        continue;\n      }\n      // We fall through to this point if the match fails\n      return 0;\n    }\n  }\n\n  // return progress\n  return cal.calcDate_(date, validation) ? parsePos[0] - start : 0;\n};\n\n\n/**\n * Calculate character repeat count in pattern.\n *\n * @param {string} pattern It describes the format of date string that need to\n *     be parsed.\n * @param {number} start The position of pattern character.\n *\n * @return {number} Repeat count.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.getNextCharCount_ = function(pattern, start) {\n  var ch = pattern.charAt(start);\n  var next = start + 1;\n  while (next < pattern.length && pattern.charAt(next) == ch) {\n    next++;\n  }\n  return next - start;\n};\n\n\n/**\n * All acceptable pattern characters.\n * @private\n */\ngoog.i18n.DateTimeParse.PATTERN_CHARS_ = 'GyMdkHmsSEDahKzZvQL';\n\n\n/**\n * Pattern characters that specify numerical field.\n * @private\n */\ngoog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_ = 'MydhHmsSDkK';\n\n\n/**\n * Check if the pattern part is a numeric field.\n *\n * @param {Object} part pattern part to be examined.\n *\n * @return {boolean} true if the pattern part is numeric field.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.isNumericField_ = function(part) {\n  if (part.count <= 0) {\n    return false;\n  }\n  var i = goog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_.indexOf(\n      part.text.charAt(0));\n  return i > 0 || i == 0 && part.count < 3;\n};\n\n\n/**\n * Identify the start of an abutting numeric fields' run. Taking pattern\n * \"HHmmss\" as an example. It will try to parse 2/2/2 characters of the input\n * text, then if that fails, 1/2/2. We only adjust the width of the leftmost\n * field; the others remain fixed. This allows \"123456\" => 12:34:56, but\n * \"12345\" => 1:23:45. Likewise, for the pattern \"yyyyMMdd\" we try 4/2/2,\n * 3/2/2, 2/2/2, and finally 1/2/2. The first field of connected numeric\n * fields will be marked as abutStart, its width can be reduced to accommodate\n * others.\n *\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.markAbutStart_ = function() {\n  // abut parts are continuous numeric parts. abutStart is the switch\n  // point from non-abut to abut\n  var abut = false;\n\n  for (var i = 0; i < this.patternParts_.length; i++) {\n    if (this.isNumericField_(this.patternParts_[i])) {\n      // if next part is not following abut sequence, and isNumericField_\n      if (!abut && i + 1 < this.patternParts_.length &&\n          this.isNumericField_(this.patternParts_[i + 1])) {\n        abut = true;\n        this.patternParts_[i].abutStart = true;\n      }\n    } else {\n      abut = false;\n    }\n  }\n};\n\n\n/**\n * Skip space in the string.\n *\n * @param {string} text input string.\n * @param {Array<number>} pos where skip start, and return back where the skip\n *     stops.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.skipSpace_ = function(text, pos) {\n  var m = text.substring(pos[0]).match(/^\\s+/);\n  if (m) {\n    pos[0] += m[0].length;\n  }\n};\n\n\n/**\n * Protected method that converts one field of the input string into a\n * numeric field value.\n *\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {Object} part the pattern part for this field.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object that holds parsed value.\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParse_ = function(\n    text, pos, part, digitCount, cal) {\n  this.skipSpace_(text, pos);\n\n  var start = pos[0];\n  var ch = part.text.charAt(0);\n\n  // parse integer value if it is a numeric field\n  var value = -1;\n  if (this.isNumericField_(part)) {\n    if (digitCount > 0) {\n      if ((start + digitCount) > text.length) {\n        return false;\n      }\n      value = this.parseInt_(text.substring(0, start + digitCount), pos);\n    } else {\n      value = this.parseInt_(text, pos);\n    }\n  }\n\n  switch (ch) {\n    case 'G':  // ERA\n      value = this.matchString_(text, pos, this.dateTimeSymbols_.ERAS);\n      if (value >= 0) {\n        cal.era = value;\n      }\n      return true;\n    case 'M':  // MONTH\n    case 'L':  // STANDALONEMONTH\n      return this.subParseMonth_(text, pos, cal, value);\n    case 'E':\n      return this.subParseDayOfWeek_(text, pos, cal);\n    case 'a':  // AM_PM\n      value = this.matchString_(text, pos, this.dateTimeSymbols_.AMPMS);\n      if (value >= 0) {\n        cal.ampm = value;\n      }\n      return true;\n    case 'y':  // YEAR\n      return this.subParseYear_(text, pos, start, value, part, cal);\n    case 'Q':  // QUARTER\n      return this.subParseQuarter_(text, pos, cal, value);\n    case 'd':  // DATE\n      if (value >= 0) {\n        cal.day = value;\n      }\n      return true;\n    case 'S':  // FRACTIONAL_SECOND\n      return this.subParseFractionalSeconds_(value, pos, start, cal);\n    case 'h':  // HOUR (1..12)\n      if (value == 12) {\n        value = 0;\n      }\n    case 'K':  // HOUR (0..11)\n    case 'H':  // HOUR_OF_DAY (0..23)\n    case 'k':  // HOUR_OF_DAY (1..24)\n      if (value >= 0) {\n        cal.hours = value;\n      }\n      return true;\n    case 'm':  // MINUTE\n      if (value >= 0) {\n        cal.minutes = value;\n      }\n      return true;\n    case 's':  // SECOND\n      if (value >= 0) {\n        cal.seconds = value;\n      }\n      return true;\n\n    case 'z':  // ZONE_OFFSET\n    case 'Z':  // TIMEZONE_RFC\n    case 'v':  // TIMEZONE_GENERIC\n      return this.subparseTimeZoneInGMT_(text, pos, cal);\n    default:\n      return false;\n  }\n};\n\n\n/**\n * Parse year field. Year field is special because\n * 1) two digit year need to be resolved.\n * 2) we allow year to take a sign.\n * 3) year field participate in abut processing.\n *\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {number} start where this field start.\n * @param {number} value integer value of year.\n * @param {Object} part the pattern part for this field.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseYear_ = function(\n    text, pos, start, value, part, cal) {\n  var ch;\n  if (value < 0) {\n    // possible sign\n    ch = text.charAt(pos[0]);\n    if (ch != '+' && ch != '-') {\n      return false;\n    }\n    pos[0]++;\n    value = this.parseInt_(text, pos);\n    if (value < 0) {\n      return false;\n    }\n    if (ch == '-') {\n      value = -value;\n    }\n  }\n\n  // only if 2 digit was actually parsed, and pattern say it has 2 digit.\n  if (!ch && pos[0] - start == 2 && part.count == 2) {\n    cal.setTwoDigitYear_(value);\n  } else {\n    cal.year = value;\n  }\n  return true;\n};\n\n\n/**\n * Parse Month field.\n *\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n * @param {number} value numeric value if this field is expressed using\n *      numeric pattern, or -1 if not.\n *\n * @return {boolean} True if parsing successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseMonth_ = function(\n    text, pos, cal, value) {\n  // when month is symbols, i.e., MMM, MMMM, LLL or LLLL, value will be -1\n  if (value < 0) {\n    // Want to be able to parse both short and long forms.\n    // Try count == 4 first\n    var months = this.dateTimeSymbols_.MONTHS\n                     .concat(this.dateTimeSymbols_.STANDALONEMONTHS)\n                     .concat(this.dateTimeSymbols_.SHORTMONTHS)\n                     .concat(this.dateTimeSymbols_.STANDALONESHORTMONTHS);\n    value = this.matchString_(text, pos, months);\n    if (value < 0) {\n      return false;\n    }\n    // The months variable is multiple of 12, so we have to get the actual\n    // month index by modulo 12.\n    cal.month = (value % 12);\n    return true;\n  } else {\n    cal.month = value - 1;\n    return true;\n  }\n};\n\n\n/**\n * Parse Quarter field.\n *\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n * @param {number} value numeric value if this field is expressed using\n *      numeric pattern, or -1 if not.\n *\n * @return {boolean} True if parsing successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseQuarter_ = function(\n    text, pos, cal, value) {\n  // value should be -1, since this is a non-numeric field.\n  if (value < 0) {\n    // Want to be able to parse both short and long forms.\n    // Try count == 4 first:\n    value = this.matchString_(text, pos, this.dateTimeSymbols_.QUARTERS);\n    if (value < 0) {  // count == 4 failed, now try count == 3\n      value = this.matchString_(text, pos, this.dateTimeSymbols_.SHORTQUARTERS);\n    }\n    if (value < 0) {\n      return false;\n    }\n    cal.month = value * 3;  // First month of quarter.\n    cal.day = 1;\n    return true;\n  }\n  return false;\n};\n\n\n/**\n * Parse Day of week field.\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseDayOfWeek_ = function(\n    text, pos, cal) {\n  // Handle both short and long forms.\n  // Try count == 4 (DDDD) first:\n  var value = this.matchString_(text, pos, this.dateTimeSymbols_.WEEKDAYS);\n  if (value < 0) {\n    value = this.matchString_(text, pos, this.dateTimeSymbols_.SHORTWEEKDAYS);\n  }\n  if (value < 0) {\n    return false;\n  }\n  cal.dayOfWeek = value;\n  return true;\n};\n\n\n/**\n * Parse fractional seconds field.\n *\n * @param {number} value parsed numeric value.\n * @param {Array<number>} pos current parse position.\n * @param {number} start where this field start.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_ = function(\n    value, pos, start, cal) {\n  // Fractional seconds left-justify\n  var len = pos[0] - start;\n  cal.milliseconds = len < 3 ? value * Math.pow(10, 3 - len) :\n                               Math.round(value / Math.pow(10, len - 3));\n  return true;\n};\n\n\n/**\n * Parse GMT type timezone.\n *\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subparseTimeZoneInGMT_ = function(\n    text, pos, cal) {\n  // First try to parse generic forms such as GMT-07:00. Do this first\n  // in case localized DateFormatZoneData contains the string \"GMT\"\n  // for a zone; in that case, we don't want to match the first three\n  // characters of GMT+/-HH:MM etc.\n\n  // For time zones that have no known names, look for strings\n  // of the form:\n  //    GMT[+-]hours:minutes or\n  //    GMT[+-]hhmm or\n  //    GMT.\n  if (text.indexOf('GMT', pos[0]) == pos[0]) {\n    pos[0] += 3;  // 3 is the length of GMT\n    return this.parseTimeZoneOffset_(text, pos, cal);\n  }\n\n  // TODO(user): check for named time zones by looking through the locale\n  // data from the DateFormatZoneData strings. Should parse both short and long\n  // forms.\n  // subParseZoneString(text, start, cal);\n\n  // As a last resort, look for numeric timezones of the form\n  // [+-]hhmm as specified by RFC 822.  This code is actually\n  // a little more permissive than RFC 822.  It will try to do\n  // its best with numbers that aren't strictly 4 digits long.\n  return this.parseTimeZoneOffset_(text, pos, cal);\n};\n\n\n/**\n * Parse time zone offset.\n *\n * @param {string} text the time text to be parsed.\n * @param {Array<number>} pos Parse position.\n * @param {goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.parseTimeZoneOffset_ = function(\n    text, pos, cal) {\n  if (pos[0] >= text.length) {\n    cal.tzOffset = 0;\n    return true;\n  }\n\n  var sign = 1;\n  switch (text.charAt(pos[0])) {\n    case '-':\n      sign = -1;  // fall through\n    case '+':\n      pos[0]++;\n  }\n\n  // Look for hours:minutes or hhmm.\n  var st = pos[0];\n  var value = this.parseInt_(text, pos);\n  if (value < 0) {\n    return false;\n  }\n\n  var offset;\n  if (pos[0] < text.length && text.charAt(pos[0]) == ':') {\n    // This is the hours:minutes case\n    offset = value * 60;\n    pos[0]++;\n    value = this.parseInt_(text, pos);\n    if (value < 0) {\n      return false;\n    }\n    offset += value;\n  } else {\n    // This is the hhmm case.\n    offset = value;\n    // Assume \"-23\"..\"+23\" refers to hours.\n    if (offset < 24 && (pos[0] - st) <= 2) {\n      offset *= 60;\n    } else {\n      // todo: this looks questionable, should have more error checking\n      offset = offset % 100 + offset / 100 * 60;\n    }\n  }\n\n  offset *= sign;\n  cal.tzOffset = -offset;\n  return true;\n};\n\n\n/**\n * Parse an integer string and return integer value.\n *\n * @param {string} text string being parsed.\n * @param {Array<number>} pos parse position.\n *\n * @return {number} Converted integer value or -1 if the integer cannot be\n *     parsed.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.parseInt_ = function(text, pos) {\n  // Delocalizes the string containing native digits specified by the locale,\n  // replaces the native digits with ASCII digits. Leaves other characters.\n  // This is the reverse operation of localizeNumbers_ in datetimeformat.js.\n  if (this.dateTimeSymbols_.ZERODIGIT) {\n    var parts = [];\n    for (var i = pos[0]; i < text.length; i++) {\n      var c = text.charCodeAt(i) - this.dateTimeSymbols_.ZERODIGIT;\n      parts.push(\n          (0 <= c && c <= 9) ? String.fromCharCode(c + 0x30) : text.charAt(i));\n    }\n    text = parts.join('');\n  } else {\n    text = text.substring(pos[0]);\n  }\n\n  var m = text.match(/^\\d+/);\n  if (!m) {\n    return -1;\n  }\n  pos[0] += m[0].length;\n  return parseInt(m[0], 10);\n};\n\n\n/**\n * Attempt to match the text at a given position against an array of strings.\n * Since multiple strings in the array may match (for example, if the array\n * contains \"a\", \"ab\", and \"abc\", all will match the input string \"abcd\") the\n * longest match is returned.\n *\n * @param {string} text The string to match to.\n * @param {Array<number>} pos parsing position.\n * @param {Array<string>} data The string array of matching patterns.\n *\n * @return {number} the new start position if matching succeeded; a negative\n *     number indicating matching failure.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.matchString_ = function(text, pos, data) {\n  // There may be multiple strings in the data[] array which begin with\n  // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).\n  // We keep track of the longest match, and return that. Note that this\n  // unfortunately requires us to test all array elements.\n  var bestMatchLength = 0;\n  var bestMatch = -1;\n  var lower_text = text.substring(pos[0]).toLowerCase();\n  for (var i = 0; i < data.length; i++) {\n    var len = data[i].length;\n    // Always compare if we have no match yet; otherwise only compare\n    // against potentially better matches (longer strings).\n    if (len > bestMatchLength &&\n        lower_text.indexOf(data[i].toLowerCase()) == 0) {\n      bestMatch = i;\n      bestMatchLength = len;\n    }\n  }\n  if (bestMatch >= 0) {\n    pos[0] += bestMatchLength;\n  }\n  return bestMatch;\n};\n\n\n\n/**\n * This class hold the intermediate parsing result. After all fields are\n * consumed, final result will be resolved from this class.\n * @constructor\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_ = function() {};\n\n\n/**\n * The date's era.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.era;\n\n\n/**\n * The date's year.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.year;\n\n\n/**\n * The date's month.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.month;\n\n\n/**\n * The date's day of month.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.day;\n\n\n/**\n * The date's hour.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.hours;\n\n\n/**\n * The date's before/afternoon denominator.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.ampm;\n\n\n/**\n * The date's minutes.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.minutes;\n\n\n/**\n * The date's seconds.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.seconds;\n\n\n/**\n * The date's milliseconds.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.milliseconds;\n\n\n/**\n * The date's timezone offset.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.tzOffset;\n\n\n/**\n * The date's day of week. Sunday is 0, Saturday is 6.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.dayOfWeek;\n\n\n/**\n * 2 digit year special handling. Assuming for example that the\n * defaultCenturyStart is 6/18/1903. This means that two-digit years will be\n * forced into the range 6/18/1903 to 6/17/2003. As a result, years 00, 01, and\n * 02 correspond to 2000, 2001, and 2002. Years 04, 05, etc. correspond\n * to 1904, 1905, etc. If the year is 03, then it is 2003 if the\n * other fields specify a date before 6/18, or 1903 if they specify a\n * date afterwards. As a result, 03 is an ambiguous year. All other\n * two-digit years are unambiguous.\n *\n * @param {number} year 2 digit year value before adjustment.\n * @return {number} disambiguated year.\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_ = function(year) {\n  var now = new Date();\n  var defaultCenturyStartYear =\n      now.getFullYear() - goog.i18n.DateTimeParse.ambiguousYearCenturyStart;\n  var ambiguousTwoDigitYear = defaultCenturyStartYear % 100;\n  this.ambiguousYear = (year == ambiguousTwoDigitYear);\n  year += Math.floor(defaultCenturyStartYear / 100) * 100 +\n      (year < ambiguousTwoDigitYear ? 100 : 0);\n  return this.year = year;\n};\n\n\n/**\n * Based on the fields set, fill a Date object. For those fields that not\n * set, use the passed in date object's value.\n *\n * @param {goog.date.DateLike} date Date object to be filled.\n * @param {boolean} validation If true, input string will be checked to make\n *     sure it is valid.\n *\n * @return {boolean} false if fields specify a invalid date.\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.calcDate_ = function(\n    date, validation) {\n  // Throw exception if date if null.\n  if (date == null) {\n    throw new Error('Parameter \\'date\\' should not be null.');\n  }\n\n  // year 0 is 1 BC, and so on.\n  if (this.era != undefined && this.year != undefined && this.era == 0 &&\n      this.year > 0) {\n    this.year = -(this.year - 1);\n  }\n\n  if (this.year != undefined) {\n    date.setFullYear(this.year);\n  }\n\n  // The setMonth and setDate logic is a little tricky. We need to make sure\n  // day of month is smaller enough so that it won't cause a month switch when\n  // setting month. For example, if data in date is Nov 30, when month is set\n  // to Feb, because there is no Feb 30, JS adjust it to Mar 2. So Feb 12 will\n  // become  Mar 12.\n  var orgDate = date.getDate();\n\n  // Every month has a 1st day, this can actually be anything less than 29.\n  date.setDate(1);\n\n  if (this.month != undefined) {\n    date.setMonth(this.month);\n  }\n\n  if (this.day != undefined) {\n    date.setDate(this.day);\n  } else {\n    var maxDate =\n        goog.date.getNumberOfDaysInMonth(date.getFullYear(), date.getMonth());\n    date.setDate(orgDate > maxDate ? maxDate : orgDate);\n  }\n\n  if (goog.isFunction(date.setHours)) {\n    if (this.hours == undefined) {\n      this.hours = date.getHours();\n    }\n    // adjust ampm\n    if (this.ampm != undefined && this.ampm > 0 && this.hours < 12) {\n      this.hours += 12;\n    }\n    date.setHours(this.hours);\n  }\n\n  if (goog.isFunction(date.setMinutes) && this.minutes != undefined) {\n    date.setMinutes(this.minutes);\n  }\n\n  if (goog.isFunction(date.setSeconds) && this.seconds != undefined) {\n    date.setSeconds(this.seconds);\n  }\n\n  if (goog.isFunction(date.setMilliseconds) && this.milliseconds != undefined) {\n    date.setMilliseconds(this.milliseconds);\n  }\n\n  // If validation is needed, verify that the uncalculated date fields\n  // match the calculated date fields.  We do this before we set the\n  // timezone offset, which will skew all of the dates.\n  //\n  // Don't need to check the day of week as it is guaranteed to be\n  // correct or return false below.\n  if (validation &&\n      (this.year != undefined && this.year != date.getFullYear() ||\n       this.month != undefined && this.month != date.getMonth() ||\n       this.day != undefined && this.day != date.getDate() ||\n       this.hours >= 24 || this.minutes >= 60 || this.seconds >= 60 ||\n       this.milliseconds >= 1000)) {\n    return false;\n  }\n\n  // adjust time zone\n  if (this.tzOffset != undefined) {\n    var offset = date.getTimezoneOffset();\n    date.setTime(date.getTime() + (this.tzOffset - offset) * 60 * 1000);\n  }\n\n  // resolve ambiguous year if needed\n  if (this.ambiguousYear) {  // the two-digit year == the default start year\n    var defaultCenturyStart = new Date();\n    defaultCenturyStart.setFullYear(\n        defaultCenturyStart.getFullYear() -\n        goog.i18n.DateTimeParse.ambiguousYearCenturyStart);\n    if (date.getTime() < defaultCenturyStart.getTime()) {\n      date.setFullYear(defaultCenturyStart.getFullYear() + 100);\n    }\n  }\n\n  // dayOfWeek, validation only\n  if (this.dayOfWeek != undefined) {\n    if (this.day == undefined) {\n      // adjust to the nearest day of the week\n      var adjustment = (7 + this.dayOfWeek - date.getDay()) % 7;\n      if (adjustment > 3) {\n        adjustment -= 7;\n      }\n      var orgMonth = date.getMonth();\n      date.setDate(date.getDate() + adjustment);\n\n      // don't let it switch month\n      if (date.getMonth() != orgMonth) {\n        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));\n      }\n    } else if (this.dayOfWeek != date.getDay()) {\n      return false;\n    }\n  }\n  return true;\n};\n"],
"names":["goog","provide","require","i18n","DateTimeParse","goog.i18n.DateTimeParse","pattern","opt_dateTimeSymbols","asserts","assert","undefined","DateTimeSymbols","patternParts_","dateTimeSymbols_","applyStandardPattern_","applyPattern_","ambiguousYearCenturyStart","prototype","goog.i18n.DateTimeParse.prototype.applyPattern_","inQuote","buf","i","length","ch","charAt","push","text","count","abutStart","PATTERN_CHARS_","indexOf","getNextCharCount_","markAbutStart_","goog.i18n.DateTimeParse.prototype.applyStandardPattern_","formatType","DateTimeFormat","Format","SHORT_DATETIME","MEDIUM_DATETIME","DATEFORMATS","TIMEFORMATS","DATETIMEFORMATS","replace","parse","goog.i18n.DateTimeParse.prototype.parse","date","opt_start","start","internalParse_","strictParse","goog.i18n.DateTimeParse.prototype.strictParse","goog.i18n.DateTimeParse.prototype.internalParse_","validation","cal","MyDate_","parsePos","abutPat","abutPass","subParse_","s","skipSpace_","calcDate_","goog.i18n.DateTimeParse.prototype.getNextCharCount_","next","NUMERIC_FORMAT_CHARS_","isNumericField_","goog.i18n.DateTimeParse.prototype.isNumericField_","part","goog.i18n.DateTimeParse.prototype.markAbutStart_","abut","goog.i18n.DateTimeParse.prototype.skipSpace_","pos","m","substring","match","goog.i18n.DateTimeParse.prototype.subParse_","digitCount","value","parseInt_","matchString_","ERAS","era","subParseMonth_","subParseDayOfWeek_","AMPMS","ampm","subParseYear_","subParseQuarter_","day","subParseFractionalSeconds_","hours","minutes","seconds","subparseTimeZoneInGMT_","goog.i18n.DateTimeParse.prototype.subParseYear_","setTwoDigitYear_","year","goog.i18n.DateTimeParse.prototype.subParseMonth_","months","MONTHS","concat","STANDALONEMONTHS","SHORTMONTHS","STANDALONESHORTMONTHS","month","goog.i18n.DateTimeParse.prototype.subParseQuarter_","QUARTERS","SHORTQUARTERS","goog.i18n.DateTimeParse.prototype.subParseDayOfWeek_","WEEKDAYS","SHORTWEEKDAYS","dayOfWeek","goog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_","len","milliseconds","Math","pow","round","goog.i18n.DateTimeParse.prototype.subparseTimeZoneInGMT_","parseTimeZoneOffset_","goog.i18n.DateTimeParse.prototype.parseTimeZoneOffset_","tzOffset","sign","st","offset","goog.i18n.DateTimeParse.prototype.parseInt_","ZERODIGIT","parts","c","charCodeAt","String","fromCharCode","join","parseInt","goog.i18n.DateTimeParse.prototype.matchString_","data","bestMatchLength","bestMatch","lower_text","toLowerCase","goog.i18n.DateTimeParse.MyDate_","goog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_","now","Date","defaultCenturyStartYear","getFullYear","ambiguousTwoDigitYear","ambiguousYear","floor","goog.i18n.DateTimeParse.MyDate_.prototype.calcDate_","Error","setFullYear","orgDate","getDate","setDate","setMonth","maxDate","getNumberOfDaysInMonth","getMonth","isFunction","setHours","getHours","setMinutes","setSeconds","setMilliseconds","getTimezoneOffset","setTime","getTime","defaultCenturyStart","adjustment","getDay","orgMonth"]
}
